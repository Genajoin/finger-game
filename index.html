<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ü–æ–∫–∞–∂–∏ —Ü–∏—Ñ—Ä—É! ‚úã</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Comic Sans MS', sans-serif;
      background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      color: white;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      margin-top: 15px;
      font-size: 2rem;
      text-align: center;
    }

    .game-container {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      padding: 20px;
    }

    #video-container {
      position: relative;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      background: white;
    }

    video {
      width: 400px;
      height: 300px;
      object-fit: cover;
      transform: scaleX(-1); /* –∑–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ –≤–∏–¥–µ–æ */
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .info-panel {
      background: white;
      padding: 25px;
      border-radius: 20px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.2);
      text-align: center;
      max-width: 350px;
    }

    .target {
      font-size: 5rem;
      color: #ff7f50;
      margin: 20px 0;
      font-weight: bold;
      animation: popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .feedback {
      font-size: 1.4rem;
      margin-top: 15px;
      min-height: 2em;
      color: #2c3e50;
      font-weight: bold;
    }

    .success { color: #2ecc71; }
    .error { color: #e74c3c; }

    @keyframes popIn {
      from { transform: scale(0); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    button.start-btn {
      margin-top: 20px;
      padding: 15px 30px;
      font-size: 1.2rem;
      border: none;
      background-color: #6c5ce7;
      color: white;
      border-radius: 50px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    button.start-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 18px rgba(108,92,231,0.4);
    }
  </style>
</head>
<body>

<h1>–ü–æ–∫–∞–∂–∏ —Ü–∏—Ñ—Ä—É! ‚úã</h1>

<div class="game-container">
  <div id="video-container">
    <video id="webcam" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <div class="info-panel">
    <p>–ü–æ–∫–∞–∂–∏ –Ω–∞ –ø–∞–ª—å—Ü–∞—Ö:</p>
    <div class="target" id="targetNum">?</div>
    <div class="feedback" id="feedbackText">–ù–∞–∂–º–∏ ¬´–°—Ç–∞—Ä—Ç¬ª, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!</div>
    <button class="start-btn" onclick="startGame()">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
  </div>
</div>

<!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script>
  // --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–≥—Ä—ã ---
  const MAX_FINGERS = 10; // –î–ª—è –¥–≤—É—Ö —Ä—É–∫ (–ø–æ 5 –ø–∞–ª—å—Ü–µ–≤ –Ω–∞ –∫–∞–∂–¥—É—é)
  const TARGET_DURATION = 5000; // 5 —Å–µ–∫—É–Ω–¥ –Ω–∞ –∑–∞–¥–∞–Ω–∏–µ (–µ—Å–ª–∏ –Ω–µ —É–≥–∞–¥–∞–ª)
  const CORRECT_DELAY = 4000; // 4 —Å–µ–∫—É–Ω–¥—ã –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–æ—Å–ª–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
  let currentTarget = -1;
  let gameActive = false;
  let lastTimeCorrect = 0;
  let stateStartTime = 0;
  let gameMode = "ask"; // "ask" (–∑–∞–¥–∞–Ω–∏–µ), "correct" (–ø—Ä–∞–≤–∏–ª—å–Ω–æ), "timeout" (–≤—Ä–µ–º—è –≤—ã—à–ª–æ)

  // DOM-—ç–ª–µ–º–µ–Ω—Ç—ã
  const videoElement = document.getElementById('webcam');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const targetEl = document.getElementById('targetNum');
  const feedbackEl = document.getElementById('feedbackText');

  let hands;
  let camera;

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MediaPipe
  async function setupMediaPipe() {
    hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2, // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –¥–≤—É—Ö —Ä—É–∫
      modelComplexity: 0, // –ª–µ–≥–∫–æ–≤–µ—Å–Ω–∞—è –º–æ–¥–µ–ª—å
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
      if (!gameActive) return;
      processFrame(results);
    });

    camera = new Camera(videoElement, {
      onFrame: async () => await hands.send({image: videoElement}),
      width: 400,
      height: 300
    });
  }

  // –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–∞–ª—å—Ü–µ–≤ (—Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –¥–≤—É—Ö —Ä—É–∫)
  function countFingers(landmarksList) {
    let totalCount = 0;

    for (const landmarks of landmarksList) {
      const tips = [8, 12, 16, 20]; // –ö–æ–Ω—á–∏–∫–∏ —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ, —Å—Ä–µ–¥–Ω–µ–≥–æ, –±–µ–∑—ã–º—è–Ω–Ω–æ–≥–æ, –º–∏–∑–∏–Ω—Ü–∞
      const thumbTip = 4;
      const thumbIP = 3;
      const wrist = landmarks[0];
      const middleFinger = landmarks[12];

      let count = 0;

      // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º 4 –ø–∞–ª—å—Ü–∞ (—É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π, —Å—Ä–µ–¥–Ω–∏–π, –±–µ–∑—ã–º—è–Ω–Ω—ã–π, –º–∏–∑–∏–Ω–µ—Ü)
      for (const tip of tips) {
        const dip = tip - 2; 
        if (landmarks[tip].y < landmarks[dip].y) {
          count++;
        }
      }

      // 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–æ–ª—å—à–æ–π –ø–∞–ª–µ—Ü
      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä—É–∫—É (–ª–µ–≤–∞—è –∏–ª–∏ –ø—Ä–∞–≤–∞—è)
      const isRightHand = wrist.x < middleFinger.y;

      if (isRightHand) {
        if (landmarks[thumbTip].x < landmarks[thumbIP].x) {
          count += 1;
        }
      } else {
        if (landmarks[thumbTip].x > landmarks[thumbIP].x) {
          count += 1;
        }
      }

      totalCount += count;
    }

    return Math.min(totalCount, MAX_FINGERS);
  }

  function processFrame(results) {
    // üîß –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û—á–∏—â–∞–µ–º –∫–∞–Ω–≤–∞—Å –ø–µ—Ä–µ–¥ –æ—Ç—Ä–∏—Å–æ–≤–∫–æ–π
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const landmarksList = results.multiHandLandmarks;

    if (!landmarksList || landmarksList.length === 0) {
      feedbackEl.textContent = "–ü–æ–∫–∞–∂–∏ –Ω–∞ –ø–∞–ª—å—Ü–∞—Ö!";
      feedbackEl.className = "feedback";
      return;
    }

    // –†–∏—Å—É–µ–º –≤—Å–µ —Ä—É–∫–∏
    for (const landmarks of landmarksList) {
      // üîß –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ó–µ—Ä–∫–∞–ª–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏–µ —Å–∫–µ–ª–µ—Ç–∞ (–Ω–æ –Ω–µ –≤–∏–¥–µ–æ!)
      ctx.save(); 
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(-1, 1); 
      ctx.translate(-canvas.width / 2, -canvas.height / 2);

      // –†–∏—Å—É–µ–º —Ä—É–∫—É
      drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 5});
      drawLandmarks(ctx, landmarks, {color: '#FF0000', lineWidth: 2});

      ctx.restore(); // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
    }

    const fingerCount = countFingers(landmarksList);
    
    feedbackEl.textContent = `–í–∏–∂—É ${fingerCount} –ø–∞–ª—å—Ü–∞(–æ–≤)`;

    if (currentTarget !== -1 && fingerCount === currentTarget) {
      handleCorrect(fingerCount);
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∞–π–º–∞—É—Ç–∞ –∑–∞–¥–∞–Ω–∏—è
    if (gameMode === "ask") {
      const now = Date.now();
      if (now - stateStartTime > TARGET_DURATION) {
        gameMode = "timeout";
        feedbackEl.textContent = "–í—Ä–µ–º—è –≤—ã—à–ª–æ! –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.";
        feedbackEl.className = "feedback error";
        setTimeout(() => {
          nextTarget();
        }, 2000);
      }
    }
  }

  function handleCorrect(count) {
    const now = Date.now();
    if (now - lastTimeCorrect > 800) { 
      gameMode = "correct";
      feedbackEl.textContent = "–ú–æ–ª–æ–¥–µ—Ü! –ü—Ä–∞–≤–∏–ª—å–Ω–æ! üéâ";
      feedbackEl.className = "feedback success";
      playSound(true);
      
      setTimeout(() => {
        lastTimeCorrect = now;
        nextTarget();
      }, CORRECT_DELAY);
    }
  }

  function nextTarget() {
    currentTarget = Math.floor(Math.random() * (MAX_FINGERS + 1)); // 0..10
    targetEl.textContent = currentTarget;
    feedbackEl.textContent = "–ü–æ–∫–∞–∂–∏ –Ω–∞ –ø–∞–ª—å—Ü–∞—Ö!";
    feedbackEl.className = "feedback";
    gameMode = "ask";
    stateStartTime = Date.now();
    
    targetEl.style.animation = 'none';
    void targetEl.offsetHeight; 
    targetEl.style.animation = 'popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
  }

  function playSound(isSuccess) {
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) return;
      const ctx = new AudioContext();
      const osc = ctx.createOscillator();
      const gainNode = ctx.createGain();

      osc.connect(gainNode);
      gainNode.connect(ctx.destination);

      if (isSuccess) {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(880, ctx.currentTime); 
        osc.frequency.exponentialRampToValueAtTime(1760, ctx.currentTime + 0.2);
        gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
        osc.start();
        osc.stop(ctx.currentTime + 0.5);
      }
    } catch (e) {
      console.warn("AudioContext not available or blocked");
    }
  }

  async function startGame() {
    if (gameActive) return;

    feedbackEl.textContent = "–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ...";
    
    try {
      await setupMediaPipe();
      await camera.start();
      gameActive = true;
      nextTarget();
      feedbackEl.textContent = "–ü–æ–∫–∞–∂–∏ –Ω–∞ –ø–∞–ª—å—Ü–∞—Ö!";
      feedbackEl.className = "feedback";
    } catch (err) {
      console.error(err);
      feedbackEl.textContent = "–ö–∞–º–µ—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –¥–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.";
      feedbackEl.className = "feedback error";
    }
  }

  // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞
  window.onload = async () => {
    try {
      await setupMediaPipe();
      document.querySelector('.start-btn').textContent = "‚ñ∂ –ù–∞—á–∞—Ç—å –∏–≥—Ä—É";
    } catch (e) {
      console.warn("Preload failed:", e);
    }
  };
</script>
</body>
</html>
