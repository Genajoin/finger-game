<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <meta name="theme-color" content="#ff7f50" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png" />
  <link rel="apple-touch-icon" href="icons/icon-192.png" />
  <title>–ü–æ–∫–∞–∂–∏ —Ü–∏—Ñ—Ä—É! </title>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --glass-bg: rgba(0, 0, 0, 0.45);
      --glass-bg-hover: rgba(0, 0, 0, 0.6);
      --glass-border: rgba(255, 255, 255, 0.12);
      --coral: #ff7f50;
      --green: #2ecc71;
      --orange: #f39c12;
      --red: #e74c3c;
      --text: #ffffff;
    }

    html, body {
      width: 100%;
      height: 100%;
      height: 100dvh;
      overflow: hidden;
      background: #1a1a2e;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      color: var(--text);
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* --- Fullscreen video + canvas --- */
    #webcam {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
      z-index: 0;
    }
    #webcam.mirrored {
      transform: scaleX(-1);
    }

    #canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
      pointer-events: none;
    }
    #canvas.mirrored {
      transform: scaleX(-1);
    }

    /* Confetti canvas */
    #confettiCanvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 5;
      pointer-events: none;
    }

    /* --- Glass card mixin --- */
    .glass {
      background: var(--glass-bg);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
    }

    /* --- Overlay layout --- */
    .game-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 3;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
      pointer-events: none;
    }
    .game-overlay > * {
      pointer-events: auto;
    }

    /* --- Top bar --- */
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      padding-top: calc(12px + var(--safe-top));
      gap: 10px;
    }

    .feedback-card {
      padding: 8px 16px;
      font-size: clamp(0.85rem, 2.5vw, 1.1rem);
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 50%;
    }
    .feedback-card.success {
      background: rgba(46, 204, 113, 0.6);
      border-color: rgba(46, 204, 113, 0.3);
    }
    .feedback-card.error {
      background: rgba(231, 76, 60, 0.6);
      border-color: rgba(231, 76, 60, 0.3);
    }

    .score-card {
      padding: 8px 16px;
      font-size: clamp(0.85rem, 2.5vw, 1.1rem);
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .score-card .score-value {
      color: var(--coral);
      font-size: clamp(1.1rem, 3vw, 1.5rem);
    }

    .flip-btn {
      width: 44px; height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3rem;
      cursor: pointer;
      border: none;
      color: var(--text);
      background: var(--glass-bg);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--glass-border);
      border-radius: 50%;
      transition: background 0.2s;
    }
    .flip-btn:active {
      background: var(--glass-bg-hover);
    }
    @media (hover: hover) {
      .flip-btn:hover {
        background: var(--glass-bg-hover);
      }
    }

    /* --- Center area --- */
    .center-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 1;
      pointer-events: none;
    }

    .target-container {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* SVG timer ring */
    .timer-ring {
      width: clamp(140px, 40vw, 220px);
      height: clamp(140px, 40vw, 220px);
      transform: rotate(-90deg);
      flex-shrink: 0;
    }
    .timer-ring-bg {
      fill: none;
      stroke: rgba(255, 255, 255, 0.1);
      stroke-width: 6;
    }
    .timer-ring-progress {
      fill: none;
      stroke: var(--green);
      stroke-width: 6;
      stroke-linecap: round;
      transition: stroke 0.3s;
    }

    .target-number {
      position: absolute;
      font-size: clamp(3.5rem, 15vw, 8rem);
      font-weight: 800;
      color: var(--coral);
      text-shadow: 0 4px 20px rgba(0,0,0,0.5);
      line-height: 1;
      user-select: none;
    }

    .target-hint {
      margin-top: 12px;
      font-size: clamp(0.9rem, 3vw, 1.3rem);
      font-weight: 600;
      text-shadow: 0 2px 8px rgba(0,0,0,0.7);
      opacity: 0.9;
    }

    /* --- Bottom bar --- */
    .bottom-bar {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 16px;
      padding-bottom: calc(16px + var(--safe-bottom));
      gap: 10px;
    }

    .hand-indicator {
      padding: 10px 14px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      min-width: 70px;
      transition: transform 0.15s;
    }
    .hand-indicator.pulse {
      animation: handPulse 0.3s ease-out;
    }
    .hand-emoji {
      font-size: clamp(1.5rem, 5vw, 2.2rem);
    }
    .hand-count {
      font-size: clamp(0.8rem, 2vw, 1rem);
      font-weight: 600;
      opacity: 0.9;
    }
    .hand-label {
      font-size: clamp(0.6rem, 1.5vw, 0.75rem);
      opacity: 0.6;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .start-btn {
      padding: 14px 32px;
      font-size: clamp(1rem, 3vw, 1.25rem);
      font-weight: 700;
      border: none;
      color: var(--text);
      background: var(--coral);
      border-radius: 50px;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
      box-shadow: 0 4px 20px rgba(255, 127, 80, 0.4);
      white-space: nowrap;
    }
    .start-btn:active {
      transform: scale(0.95);
    }
    .start-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .start-btn.stop {
      background: var(--red);
      box-shadow: 0 4px 20px rgba(231, 76, 60, 0.4);
    }
    @media (hover: hover) {
      .start-btn:hover:not(:disabled) {
        transform: scale(1.05);
      }
    }

    /* --- Loading screen --- */
    .loading-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 100;
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 24px;
      transition: opacity 0.4s;
    }
    .loading-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .loading-spinner {
      width: 48px; height: 48px;
      border: 4px solid rgba(255,255,255,0.15);
      border-top-color: var(--coral);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    .loading-text {
      font-size: 1.1rem;
      opacity: 0.8;
      text-align: center;
      padding: 0 20px;
    }
    .loading-emoji {
      font-size: 3rem;
      animation: popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    /* --- Animations --- */
    @keyframes popIn {
      from { transform: scale(0); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    @keyframes correctPulse {
      0% { transform: scale(1); }
      30% { transform: scale(1.2); }
      60% { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      15% { transform: translateX(-8px); }
      30% { transform: translateX(8px); }
      45% { transform: translateX(-6px); }
      60% { transform: translateX(6px); }
      75% { transform: translateX(-3px); }
      90% { transform: translateX(3px); }
    }

    @keyframes handPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.15); }
      100% { transform: scale(1); }
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .anim-pop { animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    .anim-correct { animation: correctPulse 0.5s ease-out; }
    .anim-shake { animation: shake 0.5s ease-out; }

    /* --- Portrait mode - large circle and digit --- */
    @media (orientation: portrait) {
      .timer-ring {
        width: 98vmin;
        height: 98vmin;
      }
      .target-number {
        font-size: 65vmin;
        font-weight: 900;
        -webkit-text-stroke: 4px rgba(255, 255, 255, 0.9);
        paint-order: stroke fill;
        text-shadow: 0 4px 30px rgba(0,0,0,0.9), 0 0 60px rgba(0,0,0,0.6);
      }
    }

    /* --- Landscape mode - fit within available height --- */
    @media (orientation: landscape) and (max-height: 500px) {
      .center-area {
        flex: 0 1 auto;
        min-height: 0;
        overflow: hidden;
      }
      .timer-ring {
        width: clamp(80px, 35vh, 150px);
        height: clamp(80px, 35vh, 150px);
      }
      .target-number {
        font-size: clamp(2.5rem, 25vh, 5rem);
      }
      .target-hint {
        margin-top: 4px;
        font-size: 0.8rem;
      }
      .bottom-bar {
        padding: 8px 16px;
        padding-bottom: calc(8px + var(--safe-bottom));
      }
      .hand-indicator {
        padding: 6px 10px;
        min-width: 55px;
        gap: 2px;
      }
      .hand-emoji {
        font-size: 1.3rem;
      }
      .hand-label {
        font-size: 0.6rem;
      }
      .start-btn {
        padding: 8px 20px;
        font-size: 0.9rem;
      }
    }

    /* --- Desktop tweaks --- */
    @media (min-width: 768px) {
      .hand-indicator {
        min-width: 90px;
        padding: 12px 18px;
      }
      .top-bar, .bottom-bar {
        padding-left: 24px;
        padding-right: 24px;
      }
    }
  </style>
</head>
<body>

<!-- Fullscreen video + hand skeleton canvas -->
<video id="webcam" autoplay playsinline muted class="mirrored"></video>
<canvas id="canvas" class="mirrored"></canvas>
<canvas id="confettiCanvas"></canvas>

<!-- Loading screen -->
<div class="loading-screen" id="loadingScreen">
  <div class="loading-emoji">&#9995;</div>
  <div class="loading-spinner"></div>
  <div class="loading-text" id="loadingText">–ó–∞–≥—Ä—É–∑–∫–∞ MediaPipe...</div>
</div>

<!-- Game overlay -->
<div class="game-overlay" id="gameOverlay">
  <!-- Top bar: feedback, score, flip -->
  <div class="top-bar">
    <div class="feedback-card glass" id="feedbackCard">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
    <div class="score-card glass" id="scoreCard">
      <span>&#9733;</span>
      <span class="score-value" id="scoreValue">0</span>
    </div>
    <button class="flip-btn" id="flipBtn" title="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É" aria-label="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É">&#128260;</button>
  </div>

  <!-- Center: target number + timer ring -->
  <div class="center-area">
    <div class="target-container" id="targetContainer">
      <svg class="timer-ring" viewBox="0 0 120 120" id="timerRing">
        <circle class="timer-ring-bg" cx="60" cy="60" r="54" />
        <circle class="timer-ring-progress" cx="60" cy="60" r="54"
                stroke-dasharray="339.292" stroke-dashoffset="0" id="timerProgress" />
      </svg>
      <div class="target-number" id="targetNum">?</div>
    </div>
    <div class="target-hint" id="targetHint">&#128075; –ü–æ–∫–∞–∂–∏ –Ω–∞ –ø–∞–ª—å—Ü–∞—Ö!</div>
  </div>

  <!-- Bottom bar: left hand, start/stop, right hand -->
  <div class="bottom-bar">
    <div class="hand-indicator glass" id="leftHandIndicator">
      <span class="hand-emoji" id="leftHandEmoji">&#9994;</span>
      <span class="hand-count" id="leftHandCount">-</span>
      <span class="hand-label">–õ–µ–≤–∞—è</span>
    </div>

    <button class="start-btn" id="startBtn" disabled>&#9654; –°—Ç–∞—Ä—Ç</button>

    <div class="hand-indicator glass" id="rightHandIndicator">
      <span class="hand-emoji" id="rightHandEmoji">&#9994;</span>
      <span class="hand-count" id="rightHandCount">-</span>
      <span class="hand-label">–ü—Ä–∞–≤–∞—è</span>
    </div>
  </div>
</div>

<!-- MediaPipe scripts -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
  // ========== Configuration ==========
  const MAX_FINGERS = 10;
  const TARGET_DURATION = 8000;
  const CORRECT_DELAY = 2000;
  const BETWEEN_TASKS_DELAY = 1500;
  const CONSENSUS_FRAMES = 14;
  const CONSENSUS_THRESHOLD = 0.8;
  const TIMER_CIRCUMFERENCE = 2 * Math.PI * 54; // ~339.292

  // ========== State ==========
  let currentTarget = -1;
  let gameActive = false;
  let stateStartTime = 0;
  let gameMode = 'idle'; // idle, ask, correct, timeout, delay
  let score = 0;

  // Per-hand consensus buffers
  let leftHandBuffer = [];
  let rightHandBuffer = [];
  let leftConsensus = null;
  let rightConsensus = null;
  let processingCorrect = false;

  // Camera state
  let currentFacingMode = 'user'; // 'user' or 'environment'
  let currentStream = null;
  let hands = null;
  let animFrameId = null;

  // ========== DOM Elements ==========
  const videoEl = document.getElementById('webcam');
  const canvasEl = document.getElementById('canvas');
  const ctx = canvasEl.getContext('2d');
  const confettiCanvas = document.getElementById('confettiCanvas');
  const confettiCtx = confettiCanvas.getContext('2d');

  const loadingScreen = document.getElementById('loadingScreen');
  const loadingText = document.getElementById('loadingText');

  const feedbackCard = document.getElementById('feedbackCard');
  const scoreValue = document.getElementById('scoreValue');
  const flipBtn = document.getElementById('flipBtn');
  const startBtn = document.getElementById('startBtn');

  const targetContainer = document.getElementById('targetContainer');
  const targetNum = document.getElementById('targetNum');
  const targetHint = document.getElementById('targetHint');
  const timerProgress = document.getElementById('timerProgress');

  const leftHandIndicator = document.getElementById('leftHandIndicator');
  const leftHandEmoji = document.getElementById('leftHandEmoji');
  const leftHandCount = document.getElementById('leftHandCount');
  const rightHandIndicator = document.getElementById('rightHandIndicator');
  const rightHandEmoji = document.getElementById('rightHandEmoji');
  const rightHandCount = document.getElementById('rightHandCount');

  // ========== Emoji mapping for finger count ==========
  const fingerEmojis = ['\u270A', '\u261D\uFE0F', '\u270C\uFE0F', '\uD83E\uDD1F', '\uD83D\uDD90\uFE0F', '\uD83D\uDD90\uFE0F'];
  // 0=fist, 1=index, 2=peace, 3=love-you(ü§ü), 4=raised hand, 5=raised hand

  function getFingerEmoji(count) {
    if (count === null || count === undefined || count < 0) return '\u270A';
    if (count > 5) return '\uD83D\uDD90\uFE0F';
    return fingerEmojis[count];
  }

  // ========== Resize canvas to match video ==========
  function resizeCanvas() {
    canvasEl.width = window.innerWidth;
    canvasEl.height = window.innerHeight;
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // ========== Per-hand finger counting ==========
  function countFingersForOneHand(landmarks) {
    const tips = [8, 12, 16, 20];
    const pips = [6, 10, 14, 18];
    const mcps = [5, 9, 13, 17];
    const wrist = landmarks[0];
    let count = 0;

    function dist(p1, p2) {
      return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
    }

    function angle(a, b, c) {
      const ab = { x: b.x - a.x, y: b.y - a.y };
      const cb = { x: b.x - c.x, y: b.y - c.y };
      const dot = ab.x * cb.x + ab.y * cb.y;
      const magAB = Math.sqrt(ab.x ** 2 + ab.y ** 2);
      const magCB = Math.sqrt(cb.x ** 2 + cb.y ** 2);
      if (magAB === 0 || magCB === 0) return 0;
      const cosAngle = Math.max(-1, Math.min(1, dot / (magAB * magCB)));
      return Math.acos(cosAngle) * (180 / Math.PI);
    }

    // Four fingers (index, middle, ring, pinky)
    for (let i = 0; i < tips.length; i++) {
      const tip = landmarks[tips[i]];
      const pip = landmarks[pips[i]];
      const mcp = landmarks[mcps[i]];

      const distTipToMCP = dist(tip, mcp);
      const distPipToMCP = dist(pip, mcp);
      const extendedRatio = distTipToMCP / distPipToMCP;
      const pipAngle = angle(tip, pip, mcp);
      const distTipToWrist = dist(tip, wrist);
      const distMcpToWrist = dist(mcp, wrist);
      const reachRatio = distTipToWrist / distMcpToWrist;

      if (extendedRatio > 1.2 && pipAngle > 115 && reachRatio > 1.3) {
        count++;
      }
    }

    // Thumb
    const thumbTip = landmarks[4];
    const thumbIP = landmarks[3];
    const thumbMCP = landmarks[2];
    const indexTip = landmarks[8];

    const thumbAngle = angle(thumbTip, thumbIP, thumbMCP);
    const thumbTipToWrist = dist(thumbTip, wrist);
    const thumbBaseToWrist = dist(thumbMCP, wrist);
    const thumbIPToWrist = dist(thumbIP, wrist);
    const distThumbToIndex = dist(thumbTip, indexTip);
    const indexLength = dist(indexTip, landmarks[5]);
    const thumbIsOpen = distThumbToIndex > indexLength * 0.8;

    if (thumbAngle > 140 && thumbTipToWrist > thumbBaseToWrist * 0.9 &&
        thumbTipToWrist > thumbIPToWrist && thumbIsOpen) {
      count++;
    }

    return Math.min(count, 5);
  }

  // ========== Consensus ==========
  function getConsensus(buffer, rawCount) {
    buffer.push(rawCount);
    if (buffer.length > CONSENSUS_FRAMES) buffer.shift();
    if (buffer.length < CONSENSUS_FRAMES * 0.5) return null;

    const freq = {};
    for (const v of buffer) freq[v] = (freq[v] || 0) + 1;

    let maxCount = 0, best = null;
    for (const [val, cnt] of Object.entries(freq)) {
      if (cnt > maxCount) { maxCount = cnt; best = parseInt(val); }
    }
    return (maxCount / buffer.length >= CONSENSUS_THRESHOLD) ? best : null;
  }

  // ========== Process MediaPipe results ==========
  function onResults(results) {
    // Always draw skeleton (even when game not active, for feedback)
    ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

    const multiLandmarks = results.multiHandLandmarks;
    const multiHandedness = results.multiHandedness;

    if (!multiLandmarks || multiLandmarks.length === 0) {
      if (gameActive && gameMode === 'ask') {
        leftHandBuffer = [];
        rightHandBuffer = [];
        updateHandIndicators(null, null);
        feedbackCard.textContent = '\uD83D\uDC4B \u041F\u043E\u043A\u0430\u0436\u0438 \u043D\u0430 \u043F\u0430\u043B\u044C\u0446\u0430\u0445!';
        feedbackCard.className = 'feedback-card glass';
      }
      return;
    }

    // Determine canvas scale to map normalized coords to canvas pixels
    const cw = canvasEl.width;
    const ch = canvasEl.height;

    // Draw each hand's skeleton
    for (const landmarks of multiLandmarks) {
      // Scale landmarks to canvas size for drawing
      const scaledLandmarks = landmarks.map(pt => ({
        x: pt.x * cw,
        y: pt.y * ch,
        z: pt.z
      }));

      drawConnectors(ctx, scaledLandmarks, HAND_CONNECTIONS, { color: 'rgba(0,255,100,0.6)', lineWidth: 2 });
      drawLandmarks(ctx, scaledLandmarks, { color: 'rgba(255,80,60,0.8)', lineWidth: 1, radius: 3 });
    }

    if (!gameActive) return;

    // Identify left/right hands and count fingers per hand
    let rawLeft = null, rawRight = null;

    for (let i = 0; i < multiLandmarks.length; i++) {
      const landmarks = multiLandmarks[i];
      const count = countFingersForOneHand(landmarks);

      // MediaPipe labels assume mirrored input; when using rear camera the image is NOT mirrored
      let label = 'Right'; // default
      if (multiHandedness && multiHandedness[i] && multiHandedness[i].label) {
        label = multiHandedness[i].label;
      }

      // MediaPipe returns handedness from the camera's perspective.
      // For front (mirrored) camera, swap to match the user's perspective.
      if (currentFacingMode === 'user') {
        label = (label === 'Left') ? 'Right' : 'Left';
      }

      if (label === 'Left') {
        rawLeft = count;
      } else {
        rawRight = count;
      }
    }

    // Get consensus for each hand
    if (rawLeft !== null) {
      const c = getConsensus(leftHandBuffer, rawLeft);
      if (c !== null) leftConsensus = c;
    } else {
      leftHandBuffer = [];
      leftConsensus = null;
    }

    if (rawRight !== null) {
      const c = getConsensus(rightHandBuffer, rawRight);
      if (c !== null) rightConsensus = c;
    } else {
      rightHandBuffer = [];
      rightConsensus = null;
    }

    updateHandIndicators(leftConsensus, rightConsensus);

    // Total finger count
    const totalLeft = leftConsensus !== null ? leftConsensus : 0;
    const totalRight = rightConsensus !== null ? rightConsensus : 0;
    const total = totalLeft + totalRight;

    if (gameMode === 'ask') {
      const handsDetected = (leftConsensus !== null || rightConsensus !== null);
      if (handsDetected) {
        feedbackCard.textContent = `\u0412\u0438\u0436\u0443 ${total} \u043F\u0430\u043B\u044C\u0446\u0430(\u043E\u0432)`;
        feedbackCard.className = 'feedback-card glass';
      }

      if (!processingCorrect && handsDetected && currentTarget !== -1 && total === currentTarget) {
        handleCorrect();
      }
    }
  }

  // ========== Hand indicator UI ==========
  function updateHandIndicators(left, right) {
    const prevLeft = leftHandEmoji.dataset.count;
    const prevRight = rightHandEmoji.dataset.count;

    if (left !== null) {
      leftHandEmoji.textContent = getFingerEmoji(left);
      leftHandCount.textContent = left;
      if (String(left) !== prevLeft) {
        leftHandIndicator.classList.remove('pulse');
        void leftHandIndicator.offsetHeight;
        leftHandIndicator.classList.add('pulse');
      }
    } else {
      leftHandEmoji.textContent = '\u270A';
      leftHandCount.textContent = '-';
    }
    leftHandEmoji.dataset.count = left;

    if (right !== null) {
      rightHandEmoji.textContent = getFingerEmoji(right);
      rightHandCount.textContent = right;
      if (String(right) !== prevRight) {
        rightHandIndicator.classList.remove('pulse');
        void rightHandIndicator.offsetHeight;
        rightHandIndicator.classList.add('pulse');
      }
    } else {
      rightHandEmoji.textContent = '\u270A';
      rightHandCount.textContent = '-';
    }
    rightHandEmoji.dataset.count = right;
  }

  // ========== Timer ring ==========
  function updateTimerRing(progress01) {
    // progress01: 1.0 = full, 0.0 = empty
    const offset = TIMER_CIRCUMFERENCE * (1 - progress01);
    timerProgress.setAttribute('stroke-dashoffset', offset);

    if (progress01 < 0.3) {
      timerProgress.setAttribute('stroke', 'var(--red)');
    } else if (progress01 < 0.6) {
      timerProgress.setAttribute('stroke', 'var(--orange)');
    } else {
      timerProgress.setAttribute('stroke', 'var(--green)');
    }
  }

  // ========== Game timer loop ==========
  let timerInterval = null;

  function startTimerLoop() {
    stopTimerLoop();
    timerInterval = setInterval(() => {
      if (gameMode === 'ask') {
        const elapsed = Date.now() - stateStartTime;
        const remaining = Math.max(0, TARGET_DURATION - elapsed);
        updateTimerRing(remaining / TARGET_DURATION);

        if (elapsed > TARGET_DURATION) {
          handleTimeout();
        }
      }
    }, 200);
  }

  function stopTimerLoop() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  }

  // ========== Game logic ==========
  function handleCorrect() {
    processingCorrect = true;
    gameMode = 'correct';

    feedbackCard.textContent = '\uD83C\uDF89 \u041C\u043E\u043B\u043E\u0434\u0435\u0446! \u041F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E!';
    feedbackCard.className = 'feedback-card glass success';

    score += 10;
    scoreValue.textContent = score;

    targetNum.classList.add('anim-correct');
    playSound(true);
    spawnConfetti();

    setTimeout(() => {
      targetNum.classList.remove('anim-correct');
      gameMode = 'delay';
      targetNum.textContent = '...';
      targetHint.textContent = '\u0413\u043E\u0442\u043E\u0432\u044C\u0441\u044F...';
      feedbackCard.textContent = '\u0413\u043E\u0442\u043E\u0432\u044C\u0441\u044F \u043A \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C\u0443...';
      feedbackCard.className = 'feedback-card glass';
      updateTimerRing(1);

      setTimeout(() => {
        if (gameActive) nextTarget();
      }, BETWEEN_TASKS_DELAY);
    }, CORRECT_DELAY);
  }

  function handleTimeout() {
    gameMode = 'timeout';
    feedbackCard.textContent = '\u23F0 \u0412\u0440\u0435\u043C\u044F \u0432\u044B\u0448\u043B\u043E!';
    feedbackCard.className = 'feedback-card glass error';
    updateTimerRing(0);

    targetContainer.classList.add('anim-shake');

    setTimeout(() => {
      targetContainer.classList.remove('anim-shake');
      gameMode = 'delay';
      targetNum.textContent = '...';
      targetHint.textContent = '\u0413\u043E\u0442\u043E\u0432\u044C\u0441\u044F...';
      feedbackCard.textContent = '\u0413\u043E\u0442\u043E\u0432\u044C\u0441\u044F \u043A \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C\u0443...';
      feedbackCard.className = 'feedback-card glass';

      setTimeout(() => {
        if (gameActive) nextTarget();
      }, BETWEEN_TASKS_DELAY);
    }, 2000);
  }

  function nextTarget() {
    currentTarget = Math.floor(Math.random() * (MAX_FINGERS + 1));
    targetNum.textContent = currentTarget;
    targetHint.textContent = '\uD83D\uDC4B \u041F\u043E\u043A\u0430\u0436\u0438 \u043D\u0430 \u043F\u0430\u043B\u044C\u0446\u0430\u0445!';
    feedbackCard.textContent = '\u041F\u043E\u043A\u0430\u0436\u0438 \u043D\u0430 \u043F\u0430\u043B\u044C\u0446\u0430\u0445!';
    feedbackCard.className = 'feedback-card glass';
    gameMode = 'ask';
    stateStartTime = Date.now();
    updateTimerRing(1);

    leftHandBuffer = [];
    rightHandBuffer = [];
    leftConsensus = null;
    rightConsensus = null;
    processingCorrect = false;

    targetNum.classList.remove('anim-pop');
    void targetNum.offsetHeight;
    targetNum.classList.add('anim-pop');
  }

  // ========== Camera management ==========
  async function startCamera(facingMode) {
    // Stop existing stream
    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
      currentStream = null;
    }

    const constraints = {
      video: {
        facingMode: facingMode,
        width: { ideal: 1280 },
        height: { ideal: 720 }
      },
      audio: false
    };

    try {
      currentStream = await navigator.mediaDevices.getUserMedia(constraints);
      videoEl.srcObject = currentStream;
      await videoEl.play();

      // Mirror front camera
      if (facingMode === 'user') {
        videoEl.classList.add('mirrored');
        canvasEl.classList.add('mirrored');
      } else {
        videoEl.classList.remove('mirrored');
        canvasEl.classList.remove('mirrored');
      }

      currentFacingMode = facingMode;
      resizeCanvas();
    } catch (err) {
      console.error('Camera error:', err);
      throw err;
    }
  }

  // rAF loop to feed frames to MediaPipe (throttled to every 3rd frame)
  let frameSkipCount = 0;
  function startProcessingLoop() {
    stopProcessingLoop();
    frameSkipCount = 0;

    async function loop() {
      frameSkipCount++;
      if (frameSkipCount >= 3 && videoEl.readyState >= 2 && hands) {
        frameSkipCount = 0;
        try {
          await hands.send({ image: videoEl });
        } catch (e) {
          // Ignore occasional frame send errors
        }
      }
      animFrameId = requestAnimationFrame(loop);
    }
    animFrameId = requestAnimationFrame(loop);
  }

  function stopProcessingLoop() {
    if (animFrameId) {
      cancelAnimationFrame(animFrameId);
      animFrameId = null;
    }
  }

  // Flip camera
  flipBtn.addEventListener('click', async () => {
    const newMode = (currentFacingMode === 'user') ? 'environment' : 'user';
    try {
      flipBtn.disabled = true;
      await startCamera(newMode);
    } catch (e) {
      console.warn('Could not switch camera:', e);
      // Try to go back
      try { await startCamera(currentFacingMode); } catch (_) {}
    } finally {
      flipBtn.disabled = false;
    }
  });

  // ========== Start / Stop ==========
  startBtn.addEventListener('click', () => {
    if (gameActive) {
      stopGame();
    } else {
      startGame();
    }
  });

  async function startGame() {
    if (gameActive) return;

    feedbackCard.textContent = '\u0420\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u0435 \u0434\u043E\u0441\u0442\u0443\u043F \u043A \u043A\u0430\u043C\u0435\u0440\u0435...';

    try {
      if (!hands) {
        await initMediaPipe();
      }
      await startCamera(currentFacingMode);
      startProcessingLoop();

      gameActive = true;
      score = 0;
      scoreValue.textContent = score;
      startBtn.textContent = '\u23F9 \u0421\u0442\u043E\u043F';
      startBtn.classList.add('stop');

      nextTarget();
      startTimerLoop();
    } catch (err) {
      feedbackCard.textContent = '\u041E\u0448\u0438\u0431\u043A\u0430: ' + err.message;
      feedbackCard.className = 'feedback-card glass error';
    }
  }

  function stopGame() {
    gameActive = false;
    gameMode = 'idle';
    stopTimerLoop();
    stopProcessingLoop();

    if (hands) {
      hands.close();
      hands = null;
    }

    if (sharedAudioCtx && sharedAudioCtx.state !== 'closed') {
      sharedAudioCtx.close();
      sharedAudioCtx = null;
    }

    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
      currentStream = null;
    }
    videoEl.srcObject = null;

    startBtn.textContent = '\u25B6 \u0421\u0442\u0430\u0440\u0442';
    startBtn.classList.remove('stop');
    targetNum.textContent = '?';
    targetHint.textContent = '\u041D\u0430\u0436\u043C\u0438 \u0421\u0442\u0430\u0440\u0442!';
    feedbackCard.textContent = '\u041D\u0430\u0436\u043C\u0438 \u0421\u0442\u0430\u0440\u0442, \u0447\u0442\u043E\u0431\u044B \u043D\u0430\u0447\u0430\u0442\u044C!';
    feedbackCard.className = 'feedback-card glass';
    updateTimerRing(0);
    updateHandIndicators(null, null);

    ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
  }

  // ========== Sound ==========
  let sharedAudioCtx = null;

  function getAudioContext() {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return null;
    if (!sharedAudioCtx || sharedAudioCtx.state === 'closed') {
      sharedAudioCtx = new AC();
    }
    if (sharedAudioCtx.state === 'suspended') {
      sharedAudioCtx.resume();
    }
    return sharedAudioCtx;
  }

  function playSound(isSuccess) {
    try {
      const actx = getAudioContext();
      if (!actx) return;
      const osc = actx.createOscillator();
      const gain = actx.createGain();
      osc.connect(gain);
      gain.connect(actx.destination);

      if (isSuccess) {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(880, actx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1760, actx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.3, actx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + 0.5);
        osc.start();
        osc.stop(actx.currentTime + 0.5);
      }
      osc.onended = () => {
        osc.disconnect();
        gain.disconnect();
      };
    } catch (e) { /* ignore */ }
  }

  // ========== Confetti ==========
  let confettiParticles = [];
  let confettiAnimId = null;

  function spawnConfetti() {
    const colors = ['#ff7f50', '#2ecc71', '#f39c12', '#e74c3c', '#6c5ce7', '#00cec9', '#fd79a8'];
    const cx = confettiCanvas.width / 2;
    const cy = confettiCanvas.height * 0.4;

    for (let i = 0; i < 40; i++) {
      confettiParticles.push({
        x: cx + (Math.random() - 0.5) * 60,
        y: cy + (Math.random() - 0.5) * 30,
        vx: (Math.random() - 0.5) * 12,
        vy: (Math.random() - 1) * 10 - 3,
        size: Math.random() * 8 + 4,
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * 360,
        rotSpeed: (Math.random() - 0.5) * 15,
        life: 1.0,
        decay: 0.008 + Math.random() * 0.012
      });
    }

    if (!confettiAnimId) {
      animateConfetti();
    }
  }

  function animateConfetti() {
    confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

    for (let i = confettiParticles.length - 1; i >= 0; i--) {
      const p = confettiParticles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.3; // gravity
      p.rotation += p.rotSpeed;
      p.life -= p.decay;

      if (p.life <= 0) {
        confettiParticles.splice(i, 1);
        continue;
      }

      confettiCtx.save();
      confettiCtx.translate(p.x, p.y);
      confettiCtx.rotate((p.rotation * Math.PI) / 180);
      confettiCtx.globalAlpha = p.life;
      confettiCtx.fillStyle = p.color;
      confettiCtx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
      confettiCtx.restore();
    }

    if (confettiParticles.length > 0) {
      confettiAnimId = requestAnimationFrame(animateConfetti);
    } else {
      confettiAnimId = null;
    }
  }

  // ========== MediaPipe Initialization ==========
  async function initMediaPipe() {
    if (typeof Hands === 'undefined') {
      throw new Error('MediaPipe Hands not loaded');
    }

    hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 0,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // Initialize model by sending a blank frame
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = 64;
    tempCanvas.height = 64;
    try {
      await hands.send({ image: tempCanvas });
    } catch (e) {
      // Expected on first send sometimes
    }
  }

  // ========== Boot ==========
  window.addEventListener('load', async () => {
    let attempts = 0;
    const maxAttempts = 100;

    const checkLoaded = () =>
      typeof Hands !== 'undefined' &&
      typeof drawConnectors !== 'undefined' &&
      typeof drawLandmarks !== 'undefined' &&
      typeof HAND_CONNECTIONS !== 'undefined';

    while (!checkLoaded() && attempts < maxAttempts) {
      await new Promise(r => setTimeout(r, 100));
      attempts++;
      if (attempts % 10 === 0) {
        loadingText.textContent = `\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 MediaPipe... (${attempts / 10}\u0441)`;
      }
    }

    if (!checkLoaded()) {
      loadingText.textContent = '\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438. \u041E\u0431\u043D\u043E\u0432\u0438\u0442\u0435 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443.';
      return;
    }

    try {
      loadingText.textContent = '\u0418\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u043C\u043E\u0434\u0435\u043B\u0438...';
      await initMediaPipe();

      loadingScreen.classList.add('hidden');
      startBtn.disabled = false;
      feedbackCard.textContent = '\u041D\u0430\u0436\u043C\u0438 \u0421\u0442\u0430\u0440\u0442, \u0447\u0442\u043E\u0431\u044B \u043D\u0430\u0447\u0430\u0442\u044C!';
      targetHint.textContent = '\u041D\u0430\u0436\u043C\u0438 \u0421\u0442\u0430\u0440\u0442!';
    } catch (e) {
      loadingText.textContent = '\u041E\u0448\u0438\u0431\u043A\u0430: ' + e.message;
    }
  });

  // ========== PWA Service Worker ==========
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').catch(() => {});
  }
</script>
</body>
</html>
